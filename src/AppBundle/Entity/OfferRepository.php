<?php

namespace AppBundle\Entity;

use Doctrine\ORM\EntityRepository;
use Doctrine\ORM\Tools\Pagination\Paginator;

/**
 * BookingRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class OfferRepository extends EntityRepository
{
    public function recentDeals($limit = 3) {
            $qb = $this->createQueryBuilder('Offer');
            $qb
                ->from('AppBundle:Offer', 'o')
                ->innerJoin('o.business','b')
                ->leftJoin('b.address', 'ba')
                ->innerJoin('o.treatment', 't')
                ->setMaxResults(3);

            $query = $qb->getQuery();
            $results = $query->getResult();

            return $results;
    }

    public function findByMulti($search, $pageSize = 20, $currentPage = 1){
      $qb    = $this->createQueryBuilder('Offer');
      $query = $qb
                ->from('AppBundle:Offer', 'o')
                ->innerJoin('o.availabilitySet', 'oas')
                ->leftJoin('o.business','b')
                ->leftJoin('b.address', 'ba')
                ->leftJoin('o.treatment', 't')
                ->innerJoin('oas.availabilities', 'a')
                ->where('o.isOpen = true');
                //->leftJoin('bk.recurring_appointments', 'r');

      if($this->isAvailabilitySearch($search)){
          $this->filterBookingsByAvailability($query,$qb, $search);
      }

      if($this->isLocationSearch($search)){
        $this->filterBookingsByLocation($query, $search['latitude'], $search['longitude']);
      }

      if($this->isTreatmentCategorySearch($search)){
        $this->filterOffersByTreatmentCategory($query, $qb, $search['treatment']);
      }

      if($this->isPriceSearch($search)){
          $this->filterBookingsByPrice($query,$qb,$search['price1'],$search['price2']);
      }

      $paginator = new Paginator($query, $fetchJoin = true);
      $result = $paginator
        ->getQuery()
        ->setFirstResult($pageSize * ($currentPage-1)) // set the offset
        ->setMaxResults($pageSize); // set the limit


      return $result->getResult();
    }

    public function findTodayAndTomorrowForTreatment($treatment) {

        $today = new \DateTime();
        $td_month = $today->format('m');
        $td_year = $today->format('Y');
        $td_day = $today->format('d');

        $tomorrow = new \DateTime('tomorrow');
        $tm_month = $tomorrow->format('m');
        $tm_year = $tomorrow->format('Y');
        $tm_day = $tomorrow->format('d');

        // Build the date
        $string = sprintf('%s-%s-%d 11:59PM', $tm_year, $tm_month, $tm_day);
        $timestring = strtotime($string);

        $tomorrowend = new \DateTime();
        $tomorrowend->setTimestamp($timestring);

        $qb = $this->createQueryBuilder('Availability');
        $query = $qb
                  ->from('AppBundle:Availability', 'a')
                  ->leftJoin('a.availabilitySet', 'oas')
                  ->innerJoin('oas.offer', 'o')
                  ->where('o.isOpen = true')
                  ->where('a.treatment = :treatment')
                  ->setParameter('treatment', $treatment);

        $query->add('where',
          $qb->expr()->between(
              'a.date',
              ':todaystart',
              ':tomorrowend'
          )
        )->setParameters(array(
            'todaystart' => $today,
            'tomorrowend' => $tomorrowend
        ));

        $results = $query->getQuery()->getResult();

        // We have the results. We need to filter them to see if they are today or tomorrow

        $todayArray = array();
        $tomorrowArray = array();

        $cmpFormat = 'Y-m-d';

        foreach($results as $result) {
            $date = $result->getDate();

            $f = $date->format($cmpFormat);
            if ($f == $today->format($cmpFormat)) {
                $todayArray[] = $result;
            } elseif ($f ===$tomorrow->format($cmpFormat)) {
                $tomorrowArray[] = $result;
            }
        }

        return array('today' => $todayArray, 'tomorrow' => $tomorrowArray, 'all' => $results);
    }


    public function filterBookingsByPrice(&$query, $qb, $price1, $price2){
      $query->add('where',
          $qb->expr()->between(
              's.currentPrice',
              ':price1',
              ':price2'
          )
      )->setParameters([
        'price1' => $price1,
        'price2' => $price2
      ]);
    }

    public function filterOffersByTreatmentCategory(&$query, $qb, $treatmentCategory){
      $query
        ->innerJoin('t.treatmentCategory', 'tc')
            ->andWhere('tc = :treatmentCategory OR tc.parent = :treatmentCategory')
            ->setParameter('treatmentCategory', $treatmentCategory);

            return $query;
    }

    public function filterBookingsByLocation(&$query, $latitude, $longitude){
        $miles = 3959;
        $km = 6371;
        $query
            ->setParameter('latitude', $latitude)
            ->setParameter('longitude', $longitude)
            ->setParameter('unit', $miles)
            //
            ->addSelect("( :unit * ACOS( COS( radians(:latitude) ) * COS( radians( ba.latitude ) ) * COS( radians( ba.longitude ) - radians(:longitude) ) + SIN( radians(ba.latitude) ) * SIN(radians(:latitude)) ) ) as distance")
            ->orderBy('distance', 'asc');
    }

    public function filterBookingsByAvailability(&$query, $qb, $search){

        return;
        
        $timeQ = $search['time'];
        $dayQ = $search['day'];

        $days = array();
        $dates = array();

        $tomorrow = new \DateTime('tomorrow');
        $today = new \DateTime('today');

        if ($dayQ === 'tomorrow') {
            $days[] = $today;
        } elseif ($dayQ === 'today') {
            $days[] = $tomorrow;
        } elseif ($dayQ === 'all') {
            $days[] = $today;
            $days[] = $tomorrow;
            // Want to make sure these dates are entered in
        }

        // all - Anytime
        // morning - 5 am - 12 pm
        // afternoon - 12 pm - 5 pm
        // evening - 5 pm to 12 am

        // Need to create the boundaries now

        if ($timeQ === 'all') {
            foreach($days as $day) {
                $dates[] = array(
                    $day->setTime('23', '59', '59'),
                    $day->setTime('23', '59', '59')
                );
            }
        } elseif ($timeQ === 'morning') {
            foreach($days as $day) {
                $dates[] = array(
                    $day->setTime('5', '0', '0'),
                    $day->setTime('11', '59', '59')
                );
            }
        } elseif ($timeQ === 'afternoon') {
            foreach($days as $day) {
                $dates[] = array(
                    $day->setTime('12', '0', '0'),
                    $day->setTime('16', '59', '59')
                );
            }
        } elseif ($timeQ === 'afternoon') {
            foreach($days as $day) {
                $dates[] = array(
                    $day->setTime('17', '0', '0'),
                    $day->setTime('23', '59', '59')
                );
            }
        }

        // Now we have the boundaries for the given days. We need to add them to the query
        if (count($dates) < 1) return;

        $query
            ->innerJoin('oas.availabilities', 'av');

        foreach($dates as $dateSet) {

            list($min, $max) = $dateSet;

            $query
                ->add('where',
                    $qb->expr()->between(
                        'av.date',
                        ':min',
                        ':max'
                    )
                )->setParameters(array(
                  'min' => $min,
                  'max' => $max
                ));
        }

        return $query;

    }

    public function isPriceSearch($search){
      return ($this->has('price1',$search)
              || ($this->has('price2',$search))
              ) ? true : false;
    }

    public function isTreatmentCategorySearch($search) {
      return $this->has('treatment', $search);
    }
    public function isLocationSearch($search){
      return $this->has('location',$search);
    }

    public function isTimeSearch($search){
      return ($this->has('starttime',$search)
              || ($this->has('endtime',$search))
              ) ? true : false;
    }

    public function isTimeRangeSearch($search){
        return ($this->has('starttime',$search)
                &&  ($this->has('endtime',$search))
                ) ? true : false;
    }

    public function isAvailabilitySearch($search){
      foreach(['day','starttime','endtime'] as $field){
          if($this->has($field,$search)) return true;
      }
      return false;
    }
    public function has($key,$search)
    {
        if (is_array($search))
            return array_key_exists($key, $search) ? true : false;
        else
            return false;
    }

    public function strongParams($req) {
        //All possible search fields in format: postkey=>table_abbrev.field_name
        $keys= [
                'day'=>'day',
                'time'=>'time',
                'location'=>'location',
                'treatment'=>'treatment',
                'amount_left'=>'price_min',
                'amount_right'=>'price_max'
        ];
        //searched fields and values
        $data=[];
        //build data array of fields present in post from search and their values
        foreach($keys as $key=>$field){

          if(array_key_exists($key, $req) && $val = $req[$key] ){
              if ($field === 'location') {
                 $geo = Address::geocodeZip($val);
                 if ($geo) {
                     $data['latitude'] = $geo->getLatitude();
                     $data['longitude'] = $geo->getLongitude();
                     $data['location'] = array($data['latitude'], $data['longitude']);
                 }
             } else {
                $data[$field] = $val;
            }
          }
        }

        return $data;
    }

  //if()andWhere('r.winner IN (:ids)')  ->setParameter('ids', $ids);
}
